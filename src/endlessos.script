# EOS Plymouth Theme
#
# Last modified: Feb 5, 2014 - Srdjan Grubor <sgnn7@sgnn7.org>

# Set gray background to both top and bottom of window
bg_level = 0.87;
Window.SetBackgroundTopColor(bg_level, bg_level, bg_level);
Window.SetBackgroundBottomColor(bg_level, bg_level, bg_level);

# Pixel position rounding since plymouth can't handle subsampling well
fun Round(number) {
    return Math.Int(number);
}

# Predefine some values
image_scale_factor = 0.42;
logo_scale_factor = 0.085;

forward_z_plane = 100;
back_z_plane = -100;
message_z_plane = 2;

message_display_offset = 0.93;
debug_message_display_offset = 0.83;
font_height = 12;

spinner_speed = 0.017;

# Load the background
background.original_image = ImageNew("background.png");
background.image = background.original_image.Scale(Window.GetWidth(), Window.GetHeight());
background.sprite = SpriteNew();
background.sprite.SetImage(background.image);
background.sprite.SetPosition(Window.GetX(), Window.GetY(), back_z_plane);

# Figure out the scaling of the centered assets
# XXX - All dynamic scaling removed until we get new assets
animation.target_width = image_scale_factor * Window.GetHeight();
animation.target_height = animation.target_width;

animation.target_width = Round(animation.target_width);
animation.target_height = Round(animation.target_height);
animation.target_x = Round(Window.GetX() + (Window.GetWidth() - animation.target_width) / 2);
animation.target_y = Round(Window.GetY() + (Window.GetHeight()  - animation.target_height)  / 2);

fun LoadAndCenter(image_object) {
    image_object.sprite = SpriteNew();
    image_object.sprite.SetImage(image_object.image);

    x = Round(Window.GetX() + (Window.GetWidth() - image_object.image.GetWidth()) / 2);
    y = Round(Window.GetY() + (Window.GetHeight() - image_object.image.GetHeight()) / 2);

    image_object.sprite.SetX(x);
    image_object.sprite.SetY(y);

    image_object.sprite.SetOpacity(0);
}

logo.original_image = ImageNew("logo.png");

# Some predefined and reused values
logo_aspect_ratio = logo.original_image.GetWidth() / logo.original_image.GetHeight();

# Logo has its own scaling
logo_scale.y = Round(logo_scale_factor * Window.GetHeight());
logo_scale.x = Round(logo_scale.y * logo_aspect_ratio);

# XXX - All dynamic scaling removed until we get new assets
# logo.image = logo.original_image.Scale(logo_scale.x, logo_scale.y);
logo.image = logo.original_image;

# Load the logo since that will always be present
LoadAndCenter(logo);
logo.sprite.SetOpacity(1);

# Fix the awkward offset in the logo asset by moving it down
logo.sprite.SetY(logo.sprite.GetY() + 4);

# Load the other assets
# XXX - All dynamic scaling removed until we get new assets

glowing_channel.original_image = ImageNew("circle_glow_channel.png");
# glowing_channel.image = glowing_channel.original_image.Scale(animation.target_width, animation.target_height);
glowing_channel.image = glowing_channel.original_image;
LoadAndCenter(glowing_channel);

spinner_channel.original_image = ImageNew("circle_channel.png");
# spinner_channel.image = spinner_channel.original_image.Scale(animation.target_width, animation.target_height);
spinner_channel.image = spinner_channel.original_image;
LoadAndCenter(spinner_channel);

glowing_spinner.original_image = ImageNew("circle_glow_spinner.png");
# glowing_spinner.image = glowing_spinner.original_image.Scale(animation.target_width, animation.target_height);
glowing_spinner.image = glowing_spinner.original_image;
LoadAndCenter(glowing_spinner);

spinner.original_image = ImageNew("circle_spinner.png");
# spinner.image = spinner.original_image.Scale(animation.target_width, animation.target_height);
spinner.image = spinner.original_image;
LoadAndCenter(spinner);

# If we are loading normal boot or resuming
if (Plymouth.GetMode() != "suspend" && Plymouth.GetMode() != "resume") {
    spinner_channel.sprite.SetOpacity(1);
    glowing_channel.sprite.SetOpacity(1);
    spinner.sprite.SetOpacity(1);
}

# Dialog logic
status = "normal";
fun dialog_setup() {
    local.box;
    local.lock;
    local.entry;
    local.prompt_sprite;

    box.image = ImageNew("box.png");
    lock.image = ImageNew("lock.png");
    entry.image = ImageNew("entry.png");

    box.sprite = SpriteNew();
    box.sprite.SetImage(box.image);
    box.x = Round(Window.GetX() + (Window.GetWidth()  - box.image.GetWidth()) / 2);
    box.y = Round(Window.GetY() + (Window.GetHeight() - box.image.GetHeight()) / 2);
    box.z = forward_z_plane;
    box.sprite.SetPosition(box.x, box.y, box.z);

    lock.sprite = SpriteNew();
    lock.sprite.SetImage(lock.image);
    lock.x = Round(box.x + box.image.GetWidth() / 2 - (lock.image.GetWidth() + entry.image.GetWidth()) / 2);
    lock.y = Round(box.y + (box.image.GetHeight() - lock.image.GetHeight()) / 2);
    lock.z = box.z + 1;
    lock.sprite.SetPosition(lock.x, lock.y, lock.z);

    entry.sprite = SpriteNew();
    entry.sprite.SetImage(entry.image);
    entry.x = lock.x + lock.image.GetWidth();
    entry.y = Round(box.y + (box.image.GetHeight() - entry.image.GetHeight()) / 2);
    entry.z = box.z + 1;
    entry.sprite.SetPosition(entry.x, entry.y, entry.z);

    prompt_sprite = SpriteNew();
    prompt_offset = 2 * font_height;
    prompt_sprite.SetPosition(box.x, box.y - prompt_offset, box.z);

    global.dialog.box = box;
    global.dialog.lock = lock;
    global.dialog.entry = entry;
    global.dialog.bullet_image = ImageNew("bullet.png");
    global.dialog.prompt_sprite = prompt_sprite;
    dialog_opacity(1);
}

fun dialog_opacity(opacity) {
    dialog.box.sprite.SetOpacity(opacity);
    dialog.lock.sprite.SetOpacity(opacity);
    dialog.entry.sprite.SetOpacity(opacity);
    dialog.prompt_sprite.SetOpacity(opacity);
    for (index = 0; dialog.bullet[index]; index++) {
        dialog.bullet[index].sprite.SetOpacity(opacity);
    }
}

fun display_normal_callback() {
    global.status = "normal";
    if (global.dialog) {
        dialog_opacity(0);
    }
}

fun display_password_callback(prompt, bullets) {
    global.status = "password";
    if (!global.dialog) {
        dialog_setup();
    } else {
        dialog_opacity(1);
    }

    if (prompt) {
        dialog.prompt_sprite.SetImage(Image.Text(prompt, 1.0, 1.0, 1.0, 1.0, "Sans " + font_height));
    }

    for (index = 0; dialog.bullet[index] || index < bullets; index++) { 
        if (!dialog.bullet[index]) {
            dialog.bullet[index].sprite = SpriteNew();
            dialog.bullet[index].sprite.SetImage(dialog.bullet_image);
            dialog.bullet[index].x = dialog.entry.x + index * dialog.bullet_image.GetWidth() + dialog.bullet_image.GetWidth();
            dialog.bullet[index].y = Round(dialog.entry.y + (dialog.entry.image.GetHeight() - dialog.bullet_image.GetHeight()) / 2);
            dialog.bullet[index].z = dialog.entry.z + 1;
            dialog.bullet[index].sprite.SetPosition(dialog.bullet[index].x, dialog.bullet[index].y, dialog.bullet[index].z);
        }

        if (index < bullets) {
            dialog.bullet[index].sprite.SetOpacity(1);
        } else {
            dialog.bullet[index].sprite.SetOpacity(0);
        }
    }
}

sprite_prompt = SpriteNew();
fun display_message_callback(prompt) {
    prompt = Image.Text(prompt, 1.0, 1.0, 1.0);
    sprite_prompt.SetImage(prompt);

    sprite_prompt.x = Round(Window.GetX() + (Window.GetWidth() - prompt.GetWidth()) / 2);
    sprite_prompt.y = Round(Window.GetY() + Window.GetHeight() * message_display_offset);
    sprite_prompt.SetPosition(sprite_prompt.x, sprite_prompt.y, message_z_plane);
}

debug_sprite_prompt = SpriteNew();
fun display_debug_message(message) {
    debug_message = Image.Text(message, 1.0, 1.0, 1.0);
    debug_sprite_prompt.SetImage(debug_message);

    debug_sprite_prompt.x = Round(Window.GetX() + (Window.GetWidth() - debug_message.GetWidth()) / 2);
    debug_sprite_prompt.y = Round(Window.GetY() + Window.GetHeight() * debug_message_display_offset);
    debug_sprite_prompt.SetPosition(debug_sprite_prompt.x, debug_sprite_prompt.y, message_z_plane);
}

fun display_question_callback(prompt, entry) {
    # Calculate length of string
    length = 0;
    while(entry.CharAt(length)) length++;

    display_password_callback(prompt, length);
}

# Instantiate dialog at startup to ensure all icons are loaded in memory before initrd is unmounted
# in case /usr isn't mounted yet
dialog_setup();
dialog_opacity(0);

# Register handlers for password/message callbacks
Plymouth.SetDisplayNormalFunction(display_normal_callback);
Plymouth.SetDisplayPasswordFunction(display_password_callback);
Plymouth.SetMessageFunction(display_message_callback);
Plymouth.SetDisplayQuestionFunction(display_question_callback);

# We need to do fsck only
Plymouth.SetUpdateStatusFunction(display_message_callback);

# Spinning animation
spinner_progress = 0.0;
fun timed_update_callback() {
    spinner_progress = (spinner_progress + spinner_speed) % 360;

    # Debug info
    # text_progress = Math.Int(spinner_progress * 100);
    # display_debug_message(text_progress);

    spinner_rotation = 2 * Math.Pi * spinner_progress;
    # spinner.image = spinner.original_image.Scale(animation.target_width, animation.target_height).Rotate(spinner_rotation);
    spinner.image = spinner.original_image.Rotate(spinner_rotation);
    spinner.sprite.SetImage(spinner.image);

    # glowing_spinner.image = glowing_spinner.original_image.Scale(animation.target_width, animation.target_height).Rotate(spinner_rotation);
    glowing_spinner.image = glowing_spinner.original_image.Rotate(spinner_rotation);
    glowing_spinner.sprite.SetImage(glowing_spinner.image);
}

# On refresh
fun refresh_callback() {
    # Turn off everything if there is a password prompt
    if (status != "normal") {
        logo.sprite.SetOpacity(0);
        spinner.sprite.SetOpacity(0);
        glowing_spinner.sprite.SetOpacity(0);
        spinner_channel.sprite.SetOpacity(0);
        glowing_channel.sprite.SetOpacity(0);
    # Otherwise if we're shutting down, show shutdown screen
    } else if (Plymouth.GetMode() == "shutdown") {
        dialog_opacity(0);
        logo.sprite.SetOpacity(1);
        spinner.sprite.SetOpacity(0);
        glowing_spinner.sprite.SetOpacity(0);
        spinner_channel.sprite.SetOpacity(0);
        glowing_channel.sprite.SetOpacity(0);
        return;
    # All else, update the animation for boot
    } else {
        timed_update_callback();
    }
}
Plymouth.SetRefreshFunction (refresh_callback);

# On boot progress change variables

# At 55%, loading circle is fully glowing
keyframe_loading_end = 0.45;

# At 40%, we start showing the glow logo and once loading circle is full
# it should be full opacity
keyframe_glow_ramp_start = 0.30;
keyframe_glow_ramp_full = keyframe_loading_end;
keyframe_glow_ramp_length = keyframe_glow_ramp_full - keyframe_glow_ramp_start;

# At 55% we slowly hide the glow
keyframe_glow_ramp_down = keyframe_loading_end;
keyframe_glow_ramp_end = keyframe_glow_ramp_down + keyframe_glow_ramp_length;

# At the end of hiding the glow, we slowly hide the logo
keyframe_logo_ramp_length = 0.18;
keyframe_logo_ramp_end = keyframe_glow_ramp_end + keyframe_logo_ramp_length;

# Boot progress callback
fun progress_callback(duration, progress) {
    if (Plymouth.GetMode() == "boot" && status == "normal") {
       # Debug info
       # text_progress = Math.Int(progress * 100);
       # display_debug_message(text_progress);

        # Show glow
        if (progress >= keyframe_glow_ramp_start) {
            # Ramp up and hold
            if (progress < keyframe_glow_ramp_down) {
                glow_opacity = (progress - keyframe_glow_ramp_start) * (1.0 / keyframe_glow_ramp_length);
                glow_opacity = Math.Min(1.0, glow_opacity);

                glowing_spinner.sprite.SetOpacity(glow_opacity);
                glowing_channel.sprite.SetOpacity(glow_opacity);

            # Ramp down
            } else if (progress < keyframe_glow_ramp_end) {
                glow_opacity = (progress - keyframe_glow_ramp_down) * (1.0 / keyframe_glow_ramp_length);
                glow_opacity = 1 - glow_opacity;

                spinner.sprite.SetOpacity(glow_opacity);
                spinner_channel.sprite.SetOpacity(glow_opacity);
                glowing_spinner.sprite.SetOpacity(glow_opacity);
                glowing_channel.sprite.SetOpacity(glow_opacity);

            # Ramp down logo
            } else if (progress < keyframe_logo_ramp_end) {
                glow_opacity = (progress - keyframe_glow_ramp_end) * (1.0 / keyframe_logo_ramp_length);
                glow_opacity = 1 - glow_opacity;
                logo.sprite.SetOpacity(glow_opacity);

            # If we are past the animation end, ensure that all sprites are hidden
            } else if (progress >= keyframe_logo_ramp_end) {
                logo.sprite.SetOpacity(0);
                spinner.sprite.SetOpacity(0);
                spinner_channel.sprite.SetOpacity(0);
                glowing_spinner.sprite.SetOpacity(0);
                glowing_channel.sprite.SetOpacity(0);
            }
        }
    }
}
Plymouth.SetBootProgressFunction(progress_callback);

# Escape handler
fun quit_callback() {
    dialog_opacity(0);
    spinner.sprite.SetOpacity(0);
    glowing_spinner.sprite.SetOpacity(0);
    spinner_channel.sprite.SetOpacity(0);
    glowing_channel.sprite.SetOpacity(0);

    if (Plymouth.GetMode() == "boot") {
        logo.sprite.SetOpacity(0);
    } else {
        logo.sprite.SetOpacity(1);
    }
}
Plymouth.SetQuitFunction(quit_callback);
